import { Router } from 'express';
import { prisma } from '../index.js';

const router = Router();

// GET /api/customers - Get all customers (requires userId)
router.get('/', async (req, res) => {
  try {
    const userId = req.query.userId as string | undefined;
    
    if (!userId) {
      return res.status(400).json({ 
        error: 'userId is required',
        message: 'Please provide userId query parameter to fetch customers' 
      });
    }
    
    console.log('üìù Fetching customers for user:', userId);
    
    const customers = await prisma.customer.findMany({
      where: { userId },
      orderBy: { createdAt: 'desc' },
    });
    console.log(`‚úÖ Found ${customers.length} customers`);
    res.json(customers);
  } catch (error: any) {
    console.error('‚ùå Failed to fetch customers:', error);
    console.error('Error details:', {
      message: error.message,
      code: error.code,
      meta: error.meta
    });
    res.status(500).json({ 
      error: 'Failed to fetch customers', 
      details: error.message,
      code: error.code 
    });
  }
});

// GET /api/customers/:id - Get customer by ID
router.get('/:id', async (req, res) => {
  try {
    const customer = await prisma.customer.findUnique({
      where: { id: req.params.id },
    });
    if (!customer) {
      return res.status(404).json({ error: 'Customer not found' });
    }
    res.json(customer);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch customer' });
  }
});

// POST /api/customers - Create customer
router.post('/', async (req, res) => {
  try {
    console.log('üìù Creating customer with data:', JSON.stringify(req.body, null, 2));
    
    // Remove fields that shouldn't be sent (auto-generated by Prisma or not in schema)
    const { tags, id, createdAt, updatedAt, ...customerData } = req.body;
    
    // Ensure userId is provided
    if (!customerData.userId) {
      return res.status(400).json({ error: 'userId is required' });
    }
    
    // Ensure joinDate is a Date object
    if (customerData.joinDate) {
      customerData.joinDate = new Date(customerData.joinDate);
    }
    
    const customer = await prisma.customer.create({
      data: customerData,
    });
    console.log('‚úÖ Customer created successfully:', customer.id);
    res.status(201).json(customer);
  } catch (error: any) {
    console.error('‚ùå Failed to create customer:', error);
    console.error('Error details:', {
      message: error.message,
      code: error.code,
      meta: error.meta
    });
    res.status(500).json({ error: 'Failed to create customer', details: error.message });
  }
});

// PUT /api/customers/:id - Update customer
router.put('/:id', async (req, res) => {
  try {
    const customer = await prisma.customer.update({
      where: { id: req.params.id },
      data: req.body,
    });
    res.json(customer);
  } catch (error: any) {
    if (error.code === 'P2025') {
      return res.status(404).json({ error: 'Customer not found' });
    }
    res.status(500).json({ error: 'Failed to update customer' });
  }
});

// DELETE /api/customers/:id - Delete customer
router.delete('/:id', async (req, res) => {
  try {
    const userId = req.query.userId as string | undefined;
    const cascade = req.query.cascade === 'true';
    
    // First, check if customer exists and belongs to the user (if userId provided)
    if (userId) {
      const customer = await prisma.customer.findUnique({
        where: { id: req.params.id },
        select: { userId: true },
      });
      
      if (!customer) {
        return res.status(404).json({ error: 'Customer not found' });
      }
      
      if (customer.userId !== userId) {
        return res.status(403).json({ error: 'You can only delete your own customers' });
      }
    }
    
    // If cascade deletion is requested, delete related projects and events first
    if (cascade) {
      console.log('üóëÔ∏è Cascade deletion requested for customer:', req.params.id);
      
      // Find all projects for this customer
      const projects = await prisma.project.findMany({
        where: { customerId: req.params.id },
        select: { id: true },
      });
      
      console.log(`üì¶ Found ${projects.length} projects to delete`);
      
      // Delete each project (tasks will cascade automatically via onDelete: Cascade)
      for (const project of projects) {
        try {
          await prisma.project.delete({
            where: { id: project.id },
          });
          console.log(`‚úÖ Deleted project: ${project.id}`);
        } catch (error: any) {
          console.error(`‚ùå Failed to delete project ${project.id}:`, error);
          // Continue with other deletions even if one fails
        }
      }
      
      // Find all events for this customer
      const events = await prisma.event.findMany({
        where: { customerId: req.params.id },
        select: { id: true },
      });
      
      console.log(`üìÖ Found ${events.length} events to delete`);
      
      // Delete each event
      for (const event of events) {
        try {
          await prisma.event.delete({
            where: { id: event.id },
          });
          console.log(`‚úÖ Deleted event: ${event.id}`);
        } catch (error: any) {
          console.error(`‚ùå Failed to delete event ${event.id}:`, error);
          // Continue with other deletions even if one fails
        }
      }
      
      console.log('‚úÖ Completed cascade deletion of related entities');
    }
    
    // Finally, delete the customer
    await prisma.customer.delete({
      where: { id: req.params.id },
    });
    console.log('‚úÖ Customer deleted successfully:', req.params.id);
    res.status(204).send();
  } catch (error: any) {
    console.error('‚ùå Failed to delete customer:', error);
    if (error.code === 'P2025') {
      return res.status(404).json({ error: 'Customer not found' });
    }
    res.status(500).json({ error: 'Failed to delete customer', details: error.message });
  }
});

export { router as customersRouter };

